worker_processes auto;
pid /var/run/nginx.pid;

# Required environment variables
env ADMIN_SERVICE_URL;
env BAN_DURATION_SECONDS;
env RATE_LIMIT_REQUESTS;
env RATE_LIMIT_BURST;
env MAX_RATE_LIMIT_VIOLATIONS;
env RATE_LIMIT_WINDOW;
env LOG_BUFFER_SIZE;
env LOG_FLUSH_INTERVAL;
env BANNED_IPS_FILE;

events {
    worker_connections 1024;
    multi_accept on;
}

http {
    # Basic Settings
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    server_tokens off;
    client_max_body_size 10M;
    client_body_timeout 12;
    client_header_timeout 12;

    # Buffer Settings
    client_body_buffer_size 16k;
    client_header_buffer_size 1k;
    large_client_header_buffers 2 1k;

    # MIME Types
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Enhanced Logging Settings with Milliseconds
    map $msec $millisec {
        "~^(?<sec>\d+)\.(?<ms>\d+)$" $ms;
    }

    map $time_iso8601 $timestamp {
        "~^(?<dt>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})\+(?<tz>\d{2}:\d{2})$" "$dt.$millisec+$tz";
    }

    log_format main_ext escape=json '[$timestamp] "$remote_addr" - "$remote_user" '
                       '"$request" "$status" "$body_bytes_sent" '
                       '"$http_referer" "$http_user_agent" '
                       '"forwarded_for":"$http_x_forwarded_for" '
                       '"req_time":"$request_time" '
                       '"upstream_time":"$upstream_response_time" '
                       '"upstream_status":"$upstream_status" '
                       '"host":"$host" '
                       '"server_port":"$server_port" '
                       '"request_id":"$request_id"';

    log_format security escape=json '[$timestamp] "$remote_addr" '
                       '"client":"$http_user_agent" '
                       '"forwarded_for":"$http_x_forwarded_for" '
                       '"request":"$request" '
                       '"status":"$status" '
                       '"violation_type":"$violation_type" '
                       '"details":"$details" '
                       '"request_id":"$request_id"';

    # Main access log
    access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
    
    # Security-related events only
    access_log /var/log/nginx/security.log security if=$loggable buffer=4k flush=1s;
    
    # Detailed error log with milliseconds
    error_log /var/log/nginx/error.log debug;

    # Lua Settings
    lua_package_path "/usr/local/openresty/lualib/?.lua;/usr/local/openresty/nginx/modules/?.lua;/usr/local/openresty/nginx/modules/config/?.lua;;";

    # Rate Limiting with IP Ban
    lua_shared_dict ip_blacklist 10m;
    lua_shared_dict rate_limit_count 10m;
    lua_shared_dict stats 1m;

    init_worker_by_lua_block {
        local ip_ban = require "ip_ban"
        ngx.timer.every(1, function()
            ip_ban.clean_expired_bans()
        end)
    }

    init_by_lua_block {
        local config = require "config"
        config.init()
        
        -- Store start time for uptime calculation
        ngx.shared.stats:set("start_time", ngx.time())
    }

    # Rate Limiting Zones - Using default values, can be overridden in Lua
    limit_req_zone $binary_remote_addr zone=admin_limit:10m rate=10r/s;
    limit_req_status 429;

    map $status $loggable {
        ~^[45] 1;
        default 0;
    }

    server {
        listen 80;
        server_name localhost;

        # Declare variables
        set $backend "";
        set $violation_type "";
        set $details "";

        # Check for banned IPs in rewrite phase (runs before rate limiting)
        rewrite_by_lua_block {
            local ip_ban = require "ip_ban"
            ip_ban.handle_ip_ban_check()
        }

        # Admin Service
        location /admin/ {
            access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
            access_log /var/log/nginx/security.log security if=$loggable buffer=4k flush=1s;
            
            # Rate limiting check
            access_by_lua_block {
                local admin = require "admin"
                admin.handle_access()
            }

            # Handle rate limit exceeded
            error_page 429 = @rate_limited;

            # Remove /admin/ prefix and add /api/
            rewrite ^/admin/(.*) /api/$1 break;

            # Proxy settings
            proxy_pass $backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Security headers
            proxy_hide_header X-Powered-By;
            proxy_hide_header Server;
            
            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;

            # Security
            if ($request_method !~ ^(GET|POST|PUT|DELETE|PATCH|OPTIONS)$) {
                set $violation_type "INVALID_METHOD";
                set $details "Method not allowed: $request_method";
                return 444;
            }
        }

        # Rate limit handler
        location @rate_limited {
            access_log /var/log/nginx/security.log security buffer=4k flush=1s;
            
            content_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.handle_rate_limited()
            }
        }

        # Health Check
        location /health {
            access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
            
            content_by_lua_block {
                local cjson = require "cjson"
                local utils = require "utils"
                
                -- Get shared dicts stats
                local ip_blacklist = ngx.shared.ip_blacklist
                local rate_limit_count = ngx.shared.rate_limit_count
                
                -- Calculate memory usage
                local ip_blacklist_capacity = ip_blacklist:capacity()
                local ip_blacklist_free = ip_blacklist:free_space()
                local rate_limit_capacity = rate_limit_count:capacity()
                local rate_limit_free = rate_limit_count:free_space()
                
                -- Count active bans
                local active_bans = 0
                local keys = ip_blacklist:get_keys(0)
                if keys then
                    active_bans = #keys
                end
                
                -- Build health response
                local health_data = {
                    status = "healthy",
                    timestamp = utils.get_iso8601_timestamp(),
                    version = "1.0.0",
                    metrics = {
                        memory = {
                            ip_blacklist = {
                                total_kb = math.floor(ip_blacklist_capacity / 1024),
                                used_kb = math.floor((ip_blacklist_capacity - ip_blacklist_free) / 1024),
                                free_kb = math.floor(ip_blacklist_free / 1024)
                            },
                            rate_limit = {
                                total_kb = math.floor(rate_limit_capacity / 1024),
                                used_kb = math.floor((rate_limit_capacity - rate_limit_free) / 1024),
                                free_kb = math.floor(rate_limit_free / 1024)
                            }
                        },
                        bans = {
                            active_bans = active_bans,
                            max_capacity = math.floor(ip_blacklist_capacity / 100)  -- Estimate max IPs
                        },
                        config = {
                            rate_limit = {
                                requests_per_second = ngx.shared.config and ngx.shared.config:get("rate_limit_requests") or 0,
                                burst = ngx.shared.config and ngx.shared.config:get("rate_limit_burst") or 0,
                                violations_before_ban = ngx.shared.config and ngx.shared.config:get("max_rate_limit_violations") or 0,
                                window_seconds = ngx.shared.config and ngx.shared.config:get("rate_limit_window") or 0
                            }
                        },
                        uptime_seconds = math.floor(ngx.time() - (ngx.shared.stats and ngx.shared.stats:get("start_time") or ngx.time()))
                    }
                }
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(health_data))
            }
        }

        # Deny access to . files
        location ~ /\. {
            access_log /var/log/nginx/security.log security;
            set $violation_type "DOT_FILE_ACCESS";
            set $details "Attempted to access dot file: $request_uri";
            return 403;
        }

        # Return 444 for undefined routes
        location / {
            set $violation_type "UNDEFINED_ROUTE";
            set $details "Attempted to access undefined route: $request_uri";
            return 444;
        }
    }
} 