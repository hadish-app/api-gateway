worker_processes auto;              # Automatically set number of worker processes based on CPU cores
pid /var/run/nginx.pid;            # File to store the main process ID

# Required environment variables
env ADMIN_SERVICE_URL;
env BAN_DURATION_SECONDS;
env RATE_LIMIT_REQUESTS;
env RATE_LIMIT_BURST;
env MAX_RATE_LIMIT_VIOLATIONS;
env RATE_LIMIT_WINDOW;
env LOG_BUFFER_SIZE;
env LOG_FLUSH_INTERVAL;
env BANNED_IPS_FILE;

events {
    worker_connections 1024;         # Maximum number of simultaneous connections per worker process
    multi_accept on;                 # Allow worker processes to accept multiple connections at once
}

http {
    # Basic Settings
    sendfile on;                     # Enable efficient file sending by kernel
    tcp_nopush on;                   # Optimize sending of TCP packets by buffering
    tcp_nodelay on;                  # Send data immediately without buffering
    keepalive_timeout 65;            # Keep TCP connections alive for 65 seconds
    types_hash_max_size 2048;        # Set maximum size of MIME types hash table
    server_tokens off;               # Hide nginx version in error pages and headers
    client_max_body_size 10M;        # Limit client request body size to 10MB
    client_body_timeout 12;          # Timeout for receiving client request body
    client_header_timeout 12;        # Timeout for receiving client request headers

    # Global CORS Settings
    map $request_method $cors_method {
        OPTIONS 204;
        default $request_method;
    }

    # Define CORS headers based on location
    map $uri $cors_allow_methods {
        ~^/admin/    'GET, POST, PUT, DELETE, OPTIONS';
        default     'GET, OPTIONS';
    }

    map $uri $cors_allow_headers {
        ~^/admin/   'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization';
        default     'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range';
    }

    # Global CORS headers
    add_header 'Access-Control-Allow-Origin' '*' always;
    add_header 'Access-Control-Allow-Methods' $cors_allow_methods always;
    add_header 'Access-Control-Allow-Headers' $cors_allow_headers always;
    add_header 'Access-Control-Max-Age' 1728000 always;  # 20 days
    add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;

    # Buffer Settings
    client_body_buffer_size 16k;     # Size of buffer for client request body, set to 16KB
    client_header_buffer_size 1k;    # Size of buffer for client request headers, set to 1KB
    large_client_header_buffers 4 8k; # Allow 2 buffers of 1KB each for large client headers

    # MIME Types
    include /usr/local/openresty/nginx/conf/mime.types;
    default_type application/octet-stream;

    # Enhanced Logging Settings with Milliseconds
    map $msec $millisec {
        "~^(?<sec>\d+)\.(?<ms>\d+)$" $ms;
    }

    map $time_iso8601 $timestamp {
        "~^(?<dt>\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2})\+(?<tz>\d{2}:\d{2})$" "$dt.$millisec+$tz";
    }

    log_format main_ext escape=json '[$timestamp] "$remote_addr" - "$remote_user" '
                       '"$request" "$status" "$body_bytes_sent" '
                       '"$http_referer" "$http_user_agent" '
                       '"forwarded_for":"$http_x_forwarded_for" '
                       '"req_time":"$request_time" '
                       '"upstream_time":"$upstream_response_time" '
                       '"upstream_status":"$upstream_status" '
                       '"host":"$host" '
                       '"server_port":"$server_port" '
                       '"request_id":"$request_id"';

    log_format security escape=json '[$timestamp] "$remote_addr" '
                       '"client":"$http_user_agent" '
                       '"forwarded_for":"$http_x_forwarded_for" '
                       '"request":"$request" '
                       '"status":"$status" '
                       '"violation_type":"$violation_type" '
                       '"details":"$details" '
                       '"request_id":"$request_id"';

    # Logging control
    map $status $status_requires_security_log {
        ~^[45] 1;        # Log all 4xx and 5xx errors by default
        default 0;
    }

    map $violation_type $has_security_violation {
        ""      0;       # No security logging for empty violation type
        default 1;       # Log when violation type is set
    }

    map "$status_requires_security_log$has_security_violation" $log_security {
        "~1" 1;         # Log if either condition is true
        default 0;
    }

    # Main access log
    access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
    
    # Security-related events only
    access_log /var/log/nginx/security.log security if=$log_security buffer=4k flush=1s;
    
    # Detailed error log with milliseconds
    error_log /var/log/nginx/error.log debug;

    # Lua Settings
    lua_package_path "/usr/local/openresty/lualib/?.lua;/usr/local/openresty/nginx/modules/?.lua;/usr/local/openresty/nginx/modules/config/?.lua;;";

    # Shared memory dictionaries for rate limiting, IP banning, and metrics
    # - ip_blacklist: Stores banned IP addresses and their expiration times (10MB)
    # - rate_limit_count: Tracks request counts for rate limiting (10MB)  
    # - stats: Stores runtime statistics and metrics (1MB)
    lua_shared_dict ip_blacklist 10m;
    lua_shared_dict rate_limit_count 10m;
    lua_shared_dict stats 1m;

    init_worker_by_lua_block {
        require("worker_init").init()
    }

    init_by_lua_block {
        local init = require "init"
        init.init()
    }

    server {
        listen 80;
        server_name localhost;

        # Declare variables
        set $backend "";
        set $violation_type "";
        set $details "";

        # Global OPTIONS handler
        if ($request_method = 'OPTIONS') {
            return 204;
        }

        # Check for banned IPs in rewrite phase (runs before rate limiting)
        rewrite_by_lua_block {
            local ip_ban = require "ip_ban"
            ip_ban.handle_ip_ban_check()
        }

        # Admin Service
        location /admin/ {
            access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
            access_log /var/log/nginx/security.log security if=$log_security buffer=4k flush=1s;
            
            # Rate limiting check
            access_by_lua_block {
                local admin = require "admin"
                admin.handle_access()
            }

            # Handle rate limit exceeded
            error_page 429 = @rate_limited;

            # Remove /admin/ prefix and add /api/
            rewrite ^/admin/(.*) /api/$1 break;

            # Proxy settings
            proxy_pass $backend;
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection 'upgrade';
            proxy_set_header Host $host;
            proxy_cache_bypass $http_upgrade;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # Security headers
            proxy_hide_header X-Powered-By;
            proxy_hide_header Server;
            
            # Timeouts
            proxy_connect_timeout 60s;
            proxy_send_timeout 60s;
            proxy_read_timeout 60s;
        }

        # Rate limit handler
        location @rate_limited {
            access_log /var/log/nginx/security.log security buffer=4k flush=1s;
            
            content_by_lua_block {
                local rate_limit = require "rate_limit"
                rate_limit.handle_rate_limited()
            }
        }

        # Health Check
        location /health {
            access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
            
            # Only allow GET method
            if ($request_method !~ ^(GET)$) {
                return 405;
            }
            
            content_by_lua_block {
                local cjson = require "cjson"
                local utils = require "utils"
                
                -- Get shared dicts stats
                local ip_blacklist = ngx.shared.ip_blacklist
                local rate_limit_count = ngx.shared.rate_limit_count
                
                -- Calculate memory usage
                local ip_blacklist_capacity = ip_blacklist:capacity()
                local ip_blacklist_free = ip_blacklist:free_space()
                local rate_limit_capacity = rate_limit_count:capacity()
                local rate_limit_free = rate_limit_count:free_space()
                
                -- Count active bans
                local active_bans = 0
                local keys = ip_blacklist:get_keys(0)
                if keys then
                    active_bans = #keys
                end
                
                -- Build health response
                local health_data = {
                    status = "healthy",
                    timestamp = utils.get_iso8601_timestamp(),
                    version = "1.0.0",
                    metrics = {
                        memory = {
                            ip_blacklist = {
                                total_kb = math.floor(ip_blacklist_capacity / 1024),
                                used_kb = math.floor((ip_blacklist_capacity - ip_blacklist_free) / 1024),
                                free_kb = math.floor(ip_blacklist_free / 1024)
                            },
                            rate_limit = {
                                total_kb = math.floor(rate_limit_capacity / 1024),
                                used_kb = math.floor((rate_limit_capacity - rate_limit_free) / 1024),
                                free_kb = math.floor(rate_limit_free / 1024)
                            }
                        },
                        bans = {
                            active_bans = active_bans,
                            max_capacity = math.floor(ip_blacklist_capacity / 100)  -- Estimate max IPs
                        },
                        config = {
                            rate_limit = {
                                requests_per_second = ngx.shared.config and ngx.shared.config:get("rate_limit_requests") or 0,
                                burst = ngx.shared.config and ngx.shared.config:get("rate_limit_burst") or 0,
                                violations_before_ban = ngx.shared.config and ngx.shared.config:get("max_rate_limit_violations") or 0,
                                window_seconds = ngx.shared.config and ngx.shared.config:get("rate_limit_window") or 0
                            }
                        },
                        uptime_seconds = math.floor(ngx.time() - (ngx.shared.stats and ngx.shared.stats:get("start_time") or ngx.time()))
                    }
                }
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(health_data))
            }
        }

        # Deny access to . files
        location ~ /\. {
            access_log /var/log/nginx/security.log security;
            
            content_by_lua_block {
                local error_handler = require "error_handler"
                error_handler.handle_forbidden()
            }
        }

        # Return 404 for undefined routes
        location / {
            access_log /var/log/nginx/access.log main_ext buffer=4k flush=1s;
            access_log /var/log/nginx/security.log security if=$log_security buffer=4k flush=1s;
            
            content_by_lua_block {
                local error_handler = require "error_handler"
                error_handler.handle_not_found()
            }
        }
    }
} 